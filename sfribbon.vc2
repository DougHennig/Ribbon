*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.21" SourceFile="sfribbon.vcx" CPID="1252" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS sfribbon AS sfribbonbase OF "sfribbon.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="linBottom" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Line1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Line2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Line3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Line4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Line5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tmrClick" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="RibbonDisplayButton" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="RibbonDisplayButton.imgButton" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: addtab		&& Adds a tab to the ribbon
		*m: adjusttabs		&& Adjusts the tabs so they align properly
		*m: allowshowtabsonly_assign
		*m: getlocalizedstring		&& Gets a localized version of the specified string
		*m: gettabs		&& Returns a collection of tabs
		*m: onshowtabsonly		&& Event raised when lShowTabsOnly is changed
		*m: selecttab		&& Fired when the specified tab is selected
		*m: showtabsonly		&& Display only tabs or the full ribbon
		*m: width_assign
		*p: allowshowtabsonly		&& .T. to allow displaying only tabs
		*p: cselectedtab		&& The name of the selected pad
		*p: displaytabsonly		&& .T. if we're displaying tabs only
		*p: lclickoutsidemenu		&& .T. if the user clicked outside a menu
		*p: nfullheight		&& The normal height of the ribbon
		*p: tabclass		&& The default tab class
		*p: tablibrary		&& The default tab library
		*p: themes		&& A collection of theme names
	*</DefinedPropArrayMethod>

	PROTECTED cselectedtab,nfullheight
	*<PropValue>
		allowshowtabsonly = .F.
		BackColor = 243,242,241
		controltype = Tab
		cselectedtab = 
		displaytabsonly = .F.
		Height = 130
		lclickoutsidemenu = .F.
		Name = "sfribbon"
		nfullheight = 0
		tabclass = SFRibbonTab
		tablibrary = SFRibbon.vcx
		themes = NULL
		type = Ribbon
		Width = 450
		_memberdata = <VFPData>
			<memberdata name="shortcutmenu" display="ShortcutMenu"/>
			<memberdata name="showmenu" display="ShowMenu"/>
			<memberdata name="omenu" display="oMenu"/>
			<memberdata name="addtab" display="AddTab"/>
			<memberdata name="adjusttabs" display="AdjustTabs"/>
			<memberdata name="gettabs" display="GetTabs"/>
			<memberdata name="cselectedtab" display="cSelectedTab"/>
			<memberdata name="selecttab" display="SelectTab"/>
			<memberdata name="tabclass" display="TabClass"/>
			<memberdata name="tablibrary" display="TabLibrary"/>
			<memberdata name="themes" display="Themes"/>
			<memberdata name="width" display="Width"/>
			<memberdata name="width_assign" display="Width_Assign"/>
			<memberdata name="showtabsonly" display="ShowTabsOnly"/>
			<memberdata name="nfullheight" display="nFullHeight"/>
			<memberdata name="onshowtabsonly" display="OnShowTabsOnly"/>
			<memberdata name="getlocalizedstring" display="GetLocalizedString"/>
			<memberdata name="allowshowtabsonly" display="AllowShowTabsOnly"/>
			<memberdata name="allowshowtabsonly_assign" display="AllowShowTabsOnly_Assign"/>
			<memberdata name="displaytabsonly" display="DisplayTabsOnly"/>
			<memberdata name="lclickoutsidemenu" display="lClickOutsideMenu"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'linBottom' AS line WITH ;
		BorderColor = 210,208,206, ;
		Height = 0, ;
		Left = 0, ;
		Name = "linBottom", ;
		Top = 125, ;
		Width = 450
		*< END OBJECT: BaseClass="line" />

	ADD OBJECT 'Line1' AS line WITH ;
		BorderColor = 234,234,234, ;
		Height = 0, ;
		Left = 0, ;
		Name = "Line1", ;
		Top = 126, ;
		Width = 450
		*< END OBJECT: BaseClass="line" />

	ADD OBJECT 'Line2' AS line WITH ;
		BorderColor = 238,238,238, ;
		Height = 0, ;
		Left = 0, ;
		Name = "Line2", ;
		Top = 127, ;
		Width = 450
		*< END OBJECT: BaseClass="line" />

	ADD OBJECT 'Line3' AS line WITH ;
		BorderColor = 243,243,243, ;
		Height = 0, ;
		Left = 0, ;
		Name = "Line3", ;
		Top = 128, ;
		Width = 450
		*< END OBJECT: BaseClass="line" />

	ADD OBJECT 'Line4' AS line WITH ;
		BorderColor = 247,247,247, ;
		Height = 0, ;
		Left = 0, ;
		Name = "Line4", ;
		Top = 129, ;
		Width = 450
		*< END OBJECT: BaseClass="line" />

	ADD OBJECT 'Line5' AS line WITH ;
		BorderColor = 251,251,251, ;
		Height = 0, ;
		Left = 0, ;
		Name = "Line5", ;
		Top = 130, ;
		Width = 450
		*< END OBJECT: BaseClass="line" />

	ADD OBJECT 'RibbonDisplayButton' AS sfribbonbase WITH ;
		BackStyle = 0, ;
		Height = 16, ;
		Left = 430, ;
		Name = "RibbonDisplayButton", ;
		Top = 105, ;
		type = Button, ;
		Width = 16
		*< END OBJECT: ClassLib="sfribbon.vcx" BaseClass="container" />

	ADD OBJECT 'RibbonDisplayButton.imgButton' AS image WITH ;
		Height = 16, ;
		Name = "imgButton", ;
		Picture = sfribbondownlarge.png, ;
		Width = 16
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'tmrClick' AS timer WITH ;
		Enabled = .F., ;
		Height = 23, ;
		Interval = 30, ;
		Left = 68, ;
		Name = "tmrClick", ;
		Top = 18, ;
		Width = 23
		*< END OBJECT: BaseClass="timer" />
	
	PROCEDURE addtab		&& Adds a tab to the ribbon
		*==============================================================================
		* Method:			AddTab
		* Status:			Public
		* Purpose:			Adds a tab to the ribbon
		* Author:			Doug Hennig
		* Last Revision:	12/22/2020
		* Parameters:		tcName    - the name of the tab (optional: if it isn't
		*						specified, Tab<n> is used
		*					tcClass   - the class for the tab (optional: if it isn't
		*						specified, the class in This.TabClass is used)
		*					tcLibrary - the library for the tab class (optional: if it
		*						isn't specified, the library in This.TabLibrary is
		*						used)
		* Returns:			a reference to the new tab
		* Environment in:	none
		* Environment out:	a tab was added
		*==============================================================================
		
		lparameters tcName, ;
			tcClass, ;
			tcLibrary
		local lcName, ;
			lcClass, ;
			lcLibrary
		
		* Use defaults if the parameters weren't specified.
		
		lcName    = evl(tcName,    'Tab' + transform(This.ControlCount))
		lcClass   = evl(tcClass,   This.TabClass)
		lcLibrary = evl(tcLibrary, This.TabLibrary)
		
		* Have AddControl do the work.
		
		return This.AddControl(lcName, lcClass, lcLibrary)
		
	ENDPROC

	PROCEDURE adjusttabs		&& Adjusts the tabs so they align properly
		*==============================================================================
		* Method:			AdjustTabs
		* Status:			Public
		* Purpose:			Adjusts the tabs so they align properly
		* Author:			Doug Hennig
		* Last Revision:	12/22/2020
		* Parameters:		none
		* Returns:			none
		* Environment in:	none
		* Environment out:	the position of the tabs were adjusted
		*==============================================================================
		
		local loTabs, ;
			lnI, ;
			loControl, ;
			loPrevTab
		This.Controls[1].Left = 0
		loTabs = This.GetTabs()
		for lnI = 2 to loTabs.Count
			loControl = loTabs.Item(lnI)
			if pemstatus(loControl, 'Type', 5) and loControl.Type = 'Tab'
				loPrevTab      = loTabs.Item(lnI - 1)
				loControl.Left = loPrevTab.Left + loPrevTab.Width
			endif pemstatus(loControl, 'Type', 5) ...
		next lnI
		
	ENDPROC

	PROCEDURE allowshowtabsonly_assign
		lparameters tlAllowShowTabsOnly
		This.AllowShowTabsOnly = tlAllowShowTabsOnly
		This.RibbonDisplayButton.Visible = tlAllowShowTabsOnly
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		dodefault()
		This.Themes = NULL
		
	ENDPROC

	PROCEDURE getlocalizedstring		&& Gets a localized version of the specified string
		*==============================================================================
		* Method:			GetLocalizedString
		* Status:			Public
		* Purpose:			Gets a localized version of the specified string
		* Author:			Doug Hennig
		* Last Revision:	04/03/2022
		* Parameters:		tcString - the string to localize
		* Returns:			the localized version of the string
		* Environment in:	none
		* Environment out:	none
		* Note:				override this in a subclass as needed
		*==============================================================================
		
		lparameters tcString
		return tcString
		
	ENDPROC

	PROCEDURE gettabs		&& Returns a collection of tabs
		*==============================================================================
		* Method:			GetTabs
		* Status:			Public
		* Purpose:			Returns a collection of tabs
		* Author:			Doug Hennig
		* Last Revision:	12/22/2020
		* Parameters:		none
		* Returns:			a collection of tabs
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		local loTabs, ;
			loControl
		loTabs = createobject('Collection')
		for each loControl in This.Controls foxobject
			if pemstatus(loControl, 'Type', 5) and loControl.Type = 'Tab'
				loTabs.Add(loControl)
			endif pemstatus(loControl, 'Type', 5) ...
		next lnI
		return loTabs
		
	ENDPROC

	PROCEDURE Init
		local lnI, ;
			lcTheme, ;
			lcRibbon
		
		* Match our width to the form.
		
		This.Width  = Thisform.Width
		This.Anchor = 10
		dodefault()
		
		* Create a collection of theme names.
		
		This.Themes = createobject('Collection')
		if empty(This.cThemes)
			This.Themes.Add('Colorful')
		else
			for lnI = 1 to occurs('<theme name=', This.cThemes)
				lcTheme = strextract(This.cThemes, '<theme name="', '"', lnI, 1)
				This.Themes.Add(lcTheme)
			next lnI
		endif empty(This.cThemes)
		
		* Place the RibbonDisplayButton at the far right and add a menu to show tabs
		* only or the full ribbon.
		
		This.RibbonDisplayButton.Left    = This.Width - 20
		This.RibbonDisplayButton.Visible = This.AllowShowTabsOnly
		lcRibbon = 'Thisform.' + This.Name + '.'
		This.RibbonDisplayButton.AddBar(This.GetLocalizedString('Show tabs only'), ;
			lcRibbon + 'ShowTabsOnly(.T.)', ;
			"{iif(" + lcRibbon + "DisplayTabsOnly, 'sfribboncheck.png', '')}")
		This.RibbonDisplayButton.AddBar(This.GetLocalizedString('Always show ribbon'), ;
			lcRibbon + 'ShowTabsOnly()', ;
			"{iif(" + lcRibbon + "DisplayTabsOnly, '', 'sfribboncheck.png')}")
		This.nFullHeight = This.Height
		
		* Move to the top of ZOrder so when we redisplay when showing tabs only, we're
		* on top of everything else.
		
		This.ZOrder(0)
		
		* Declare the Sleep function.
		
		declare Sleep in Win32API integer nMilliseconds
		
	ENDPROC

	PROCEDURE onshowtabsonly		&& Event raised when lShowTabsOnly is changed
		* Event method
		
		lparameters tlShowTabsOnly
		
	ENDPROC

	PROCEDURE selecttab		&& Fired when the specified tab is selected
		*==============================================================================
		* Method:			SelectTab
		* Status:			Public
		* Purpose:			Fired when the specified tab is selected
		* Author:			Doug Hennig
		* Last revision:	04/02/2022
		* Parameters:		toTab - the reference to the selected tab
		* Returns:			.T.
		* Environment in:	cSelectedTab contains the name of the formerly selected tab
		* Environment out:	the toolbar for the formerly selected tab is hidden
		*					the Selected property for the formerly selected tab is set
		*						to .F.
		*					cSelectedTab contains the name of the selected tab
		*==============================================================================
		
		* When a tab is selected, deselect the currently selected tab and hide its
		* toolbar.
		
		lparameters toTab
		local lcOldTab, ;
			lcOldToolbar, ;
			loOldToolbar, ;
			loControl, ;
			loParent
		lcOldTab = This.cSelectedTab
		if not empty(lcOldTab)
			This.&lcOldTab..Selected = .F.
			lcOldToolbar = lcOldTab + 'Toolbar'
			if type('This.' + lcOldToolbar + '.Name') = 'C'
				loOldToolbar = This.&lcOldToolbar
				loOldToolbar.Visible = .F.
		
		* If one of the controls in the toolbar has focus, hide it or else it'll still
		* be visible.
		
				if type('Thisform.ActiveControl.Name') = 'C' and ;
					pemstatus(Thisform.ActiveControl, 'Visible', 5)
					loControl = Thisform.ActiveControl
					loParent  = loControl.Parent
					do while vartype(loParent) = 'O' and loParent <> loOldToolbar and ;
						loParent <> Thisform
						loParent = loParent.Parent
					enddo while vartype(loParent) = 'O' ...
					if vartype(loParent) = 'O' and loParent = loOldToolbar
						loControl.Visible = .F.
					endif vartype(loParent) = 'O' ...
				endif type('Thisform.ActiveControl.Name') = 'C'
			endif type('This.' + lcOldToolbar + '.Name') = 'C'
		endif not empty(lcOldTab)
		This.cSelectedTab = toTab.Name
		
		* If we're displaying tabs only, expand the ribbon to show the toolbar and
		* start the timer that checks if the user clicks outside the ribbon.
		
		if This.DisplayTabsOnly
			This.ShowTabsOnly(.F., .T.)
			This.tmrClick.Enabled = .T.
		endif This.DisplayTabsOnly
		
	ENDPROC

	PROCEDURE showmenu
		lparameters tnRow, ;
			tnCol, ;
			tcName
		dodefault(tnRow, tnCol, 'nothing')
		
	ENDPROC

	PROCEDURE showtabsonly		&& Display only tabs or the full ribbon
		*==============================================================================
		* Method:			ShowTabsOnly
		* Status:			Public
		* Purpose:			Display only tabs or the full ribbon
		* Author:			Doug Hennig
		* Last Revision:	04/06/2022
		* Parameters:		tlShowTabsOnly - .T. to show tabs only
		*					tlDisplayOnly  - .T. if we're being called to update the
		*						display only
		* Returns:			none
		* Environment in:	cSelectedTab contains the name of the selected tab
		*					nFullHeight contains the normal height of the ribbon
		* Environment out:	the ribbon height and position of the lines has been
		*						adjusted and the toolbar for the selected tab has been
		*						displayed or hidden
		*					the OnShowTabsOnly event is raised
		*==============================================================================
		
		lparameters tlShowTabsOnly, ;
			tlDisplayOnly
		local lcTab
		
		* Save the setting if we're not just being called to update the display. If we
		* are just updated, pause for a bit: needed for multiple timer firing to not
		* conflict.
		
		if not tlDisplayOnly
			This.DisplayTabsOnly = tlShowTabsOnly
		else
			Sleep(100)
		endif not tlDisplayOnly
		
		* If we're showing tabs only, set the ribbon height to slightly taller than the
		* tabs. Otherwise, set it to the normal height.
		
		lcTab = This.cSelectedTab
		if tlShowTabsOnly
			This.Height           = This.&lcTab..Height + 8
			This.tmrClick.Enabled = .F.
		else
			This.Height = This.nFullHeight
		endif tlShowTabsOnly
		
		* Move the lines to the bottom of the ribbon.
		
		This.linBottom.Top = This.Height - 5
		This.line1.Top     = This.Height - 4
		This.line2.Top     = This.Height - 3
		This.line3.Top     = This.Height - 2
		This.line4.Top     = This.Height - 1
		This.line5.Top     = This.Height
		
		* Show or hide the selected tab's toolbar.
		
		This.&lcTab..Toolbar.Visible = not tlShowTabsOnly
		
		* Raise the OnShowTabsOnly event so the form can do something about it.
		
		if not tlDisplayOnly
			raiseevent(This, 'OnShowTabsOnly', tlShowTabsOnly)
		endif not tlDisplayOnly
		
	ENDPROC

	PROCEDURE theme_assign
		lparameters tcTheme
		dodefault(tcTheme)
		if not empty(This.cThemeColors)
			This.BackColor             = This.GetThemeColor('ribbonbackcolor')
			This.linBottom.BorderColor = This.GetThemeColor('ribbonbordercolor')
			This.Line1.BorderColor     = This.GetThemeColor('ribbonshadowcolor1')
			This.Line2.BorderColor     = This.GetThemeColor('ribbonshadowcolor2')
			This.Line3.BorderColor     = This.GetThemeColor('ribbonshadowcolor3')
			This.Line4.BorderColor     = This.GetThemeColor('ribbonshadowcolor4')
			This.Line5.BorderColor     = This.GetThemeColor('ribbonshadowcolor5')
		endif not empty(This.cThemeColors)
		
	ENDPROC

	PROCEDURE width_assign
		lparameters tnWidth
		This.Width = tnWidth
		store tnWidth to This.linBottom.Width, This.Line1.Width, This.Line2.Width, ;
			This.Line3.Width, This.Line4.Width, This.Line5.Width
		This.RibbonDisplayButton.Left = tnWidth - 20
		
	ENDPROC

	PROCEDURE RibbonDisplayButton.imgButton.Click
		This.Parent.ShowMenu()
		
	ENDPROC

	PROCEDURE RibbonDisplayButton.MouseEnter
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		This.imgButton.BorderStyle = 1
		
	ENDPROC

	PROCEDURE RibbonDisplayButton.MouseLeave
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		This.imgButton.BorderStyle = 0
		
	ENDPROC

	PROCEDURE RibbonDisplayButton.showmenu
		* Display the menu below ourselves.
		
		local llInScreen
		llInScreen = Thisform.HWnd = _screen.HWnd
		*** TODO: the menu isn't quite in the correct position when used in a top-level form
		***			but without the IF llInScreen, the timer kills the menu right after it's
		***			displayed
		*** TODO: if the ribbon is in _SCREEN, the timer kills the menu right after it's displayed
		if llInScreen
			dodefault(objtoclient(This, 1) + ;
					This.Height + Thisform.Top + ;
					iif(llInScreen, 0, sysmetric(9) + sysmetric(4)) + ;
					iif(Thisform.Desktop or llInScreen, 0, sysmetric(9) + sysmetric(20)), ;
				objtoclient(This, 2) + Thisform.Left + iif(llInScreen, 0, sysmetric(3)))
		else
			dodefault()
		endif llInScreen
		
	ENDPROC

	PROCEDURE tmrClick.Timer
		* If the user clicks outside the ribbon when we're showing tabs only, redisplay
		* tabs only.
		
		local llDown, ;
			laMouse[1], ;
			lnMouse, ;
			llClickOutsideRibbon
		#define VK_LBUTTON 0x01
		declare integer GetAsyncKeyState in user32 integer vKey
		llDown               = GetAsyncKeyState(VK_LBUTTON) > 0 or mdown()
			&& use GetAsyncKeyState because MDOWN() is .F. if click outside form
		lnMouse              = amouseobj(laMouse, 1)
		llClickOutsideRibbon = llDown and (lnMouse = 0 or ;
			not between(laMouse[3], This.Parent.Left, This.Parent.Left + This.Parent.Width) or ;
			not between(laMouse[4], This.Parent.Top, This.Parent.Top + This.Parent.Height))
		if llClickOutsideRibbon
			This.Parent.ShowTabsOnly(.T., .T.)
			This.Enabled = .F.
		endif llClickOutsideRibbon
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfribbonbase AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: addbar		&& Adds a bar to the dropdown menu
		*m: addcontrol		&& Adds a control to the container
		*m: enabled_assign
		*m: getcolor		&& Gets the value of the specified color
		*m: getthemecolor		&& Gets the specified color for the current theme
		*m: padding_assign
		*m: showmenu		&& Displays a shortcut menu
		*m: theme_assign
		*p: controltype		&& The type of control this contains
		*p: cthemecolors		&& The colors for the current theme
		*p: cthemes		&& The XML defining the themes
		*p: ogdi		&& A reference to an SFGDIMeasureString object
		*p: padding		&& The space between the left edge and the first control
		*p: theme		&& The theme to use
		*p: type		&& The type of control this is
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED cthemecolors,cthemes,ogdi
	*<PropValue>
		BorderWidth = 0
		controltype = 
		cthemecolors = 
		cthemes = 
		Enabled = .T.
		Height = 65
		Name = "sfribbonbase"
		ogdi = .NULL.
		padding = 0
		theme = Colorful
		type = 
		Width = 100
		_memberdata = <VFPData>
			<memberdata name="showmenu" display="ShowMenu"/>
			<memberdata name="ogdi" display="oGDI"/>
			<memberdata name="controltype" display="ControlType"/>
			<memberdata name="padding" display="Padding"/>
			<memberdata name="getcolor" display="GetColor"/>
			<memberdata name="padding_assign" display="Padding_Assign"/>
			<memberdata name="type" display="Type"/>
			<memberdata name="enabled" display="Enabled"/>
			<memberdata name="enabled_assign" display="Enabled_Assign"/>
			<memberdata name="theme" display="Theme"/>
			<memberdata name="theme_assign" display="Theme_Assign"/>
			<memberdata name="addcontrol" display="AddControl"/>
			<memberdata name="cthemes" display="cThemes"/>
			<memberdata name="cthemecolors" display="cThemeColors"/>
			<memberdata name="addbar" display="AddBar"/>
			<memberdata name="getthemecolor" display="GetThemeColor"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE addbar		&& Adds a bar to the dropdown menu
		*==============================================================================
		* Method:			AddBar
		* Status:			Public
		* Purpose:			Adds a bar to the dropdown menu
		* Author:			Doug Hennig
		* Last Revision:	12/27/2020
		* Parameters:		tcPrompt  - the prompt for the bar
		*					tcCommand - the command to execute
		*					tcImage   - the image for the bar
		*					tcEnabled - the expression that enables the bar (optional)
		* Returns:			a reference to the new bar
		* Environment in:	This.Menu contains an SFRibbonMenu object
		* Environment out:	a bar was added to the menu
		*==============================================================================
		
		lparameters tcPrompt, ;
			tcCommand, ;
			tcImage, ;
			tcEnabled
		local loBar
		loBar = This.Menu.AddBar(tcPrompt, tcCommand, tcImage, tcEnabled)
		return loBar
		
	ENDPROC

	PROCEDURE addcontrol		&& Adds a control to the container
		*==============================================================================
		* Method:			AddControl
		* Status:			Protected
		* Purpose:			Adds a control to the container
		* Author:			Doug Hennig
		* Last Revision:	04/03/2022
		* Parameters:		tcName    - the name of the control
		*					tcClass   - the class for the control
		*					tcLibrary - the library for the control
		* Returns:			a reference to the new control
		* Environment in:	none
		* Environment out:	a control was added
		*==============================================================================
		
		lparameters tcName, ;
			tcClass, ;
			tcLibrary
		local lnLeft, ;
			lnControls, ;
			loControl
		
		* Figure out what position to use.
		
		lnLeft     = 0
		lnControls = 0
		for each loControl in This.Controls foxobject
			if pemstatus(loControl, 'Type', 5) and loControl.Type = This.ControlType
				lnControls = lnControls + 1
				lnLeft     = max(lnLeft, loControl.Left + loControl.Width)
			endif pemstatus(loControl, 'Type', 5) ...
		next loControl
		
		* Add the control and set its properties.
		
		This.NewObject(tcName, tcClass, tcLibrary)
		loControl = This.&tcName
		with loControl
			.Left    = max(lnLeft, iif(lnControls = 0, 0, This.Padding))
			.Visible = .T.
		endwith
		return loControl
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oGDI  = NULL
		loThisform = NULL
		
	ENDPROC

	PROCEDURE enabled_assign
		lparameters tlEnabled
		if This.Enabled <> tlEnabled
			This.Enabled = tlEnabled
			This.SetAll('Enabled', tlEnabled)
		endif This.Enabled <> tlEnabled
		
	ENDPROC

	PROCEDURE getcolor		&& Gets the value of the specified color
		*==============================================================================
		* Method:			GetColor
		* Status:			Public
		* Purpose:			Gets the value of the specified color
		* Author:			Doug Hennig
		* Last Revision:	12/25/2020
		* Parameters:		tuColor - the color as a string (e.g. "255,255,255" or
		*						"RGB(255, 255, 255)") or a numeric RGB value
		* Returns:			the color as an RGB value
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tuColor
		local lnColor
		do case
			case vartype(tuColor) = 'N'
				lnColor = tuColor
			case not ',' $ tuColor
				lnColor = val(tuColor)
			case upper(left(tuColor, 4)) = 'RGB('
				lnColor = evaluate(tuColor)
			otherwise
				lnColor = evaluate('RGB(' + tuColor + ')')
		endcase
		return lnColor
		
	ENDPROC

	PROCEDURE getthemecolor		&& Gets the specified color for the current theme
		*==============================================================================
		* Method:			GetThemeColor
		* Status:			Public
		* Purpose:			Gets the specified color for the current theme
		* Author:			Doug Hennig
		* Last Revision:	07/23/2023
		* Parameters:		tcColorName - the name of the color to get
		* Returns:			the numeric color value for the specified color
		* Environment in:	This.cThemeColors contains the colors for the current theme
		* Environment out:	none
		*==============================================================================
		
		lparameters tcColorName
		local lcColor, ;
			lnColor
		lcColor = strextract(This.cThemeColors, tcColorName + '="', '"')
		lnColor = This.GetColor(lcColor)
		return lnColor
		
	ENDPROC

	PROCEDURE Init
		* Instantiate an SFGDIMeasureString object.
		
		This.oGDI = newobject('SFGDIMeasureString', 'SFGDIMeasureString.prg')
		
		* Create an SFRibbonMenu object.
		
		This.NewObject('Menu', 'SFRibbonMenu', 'SFRibbon.vcx')
		
		* Read in the theme colors.
		
		if file('RibbonThemes.xml')
			This.cThemes = filetostr('RibbonThemes.xml')
			This.Theme   = This.Theme
		endif file('RibbonThemes.xml')
		
	ENDPROC

	PROCEDURE padding_assign
		lparameters tnPadding
		This.Padding = tnPadding
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE showmenu		&& Displays a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Last revision:	04/05/2022
		* Parameters:		tnRow  - the row for the menu (optional: if it isn't
		*						specified, the mouse position is used)
		*					tnCol  - the column for the menu (optional: if it isn't
		*						specified, the mouse position is used)
		*					tcName - the name of the object that fired the menu
		*						(optional: if it isn't passed, This.Name is used)
		* Returns:			.T.
		* Environment in:	This.Menu contains a reference to the menu
		* Environment out:	a menu was displayed if it has any bars
		*==============================================================================
		
		lparameters tnRow, ;
			tnCol, ;
			tcName
		local lnRow, ;
			lnCol, ;
			lcName
		
		* If the menu is visible, close it.
		
		if This.Menu.Visible
			This.Menu.HideMenu()
			release loThisform
			return
		endif This.Menu.Visible
		
		* Put a reference to the form into a variable so we can access it in the
		* menu.
		
		if type('loThisform.Name') <> 'C'
			public loThisform
			loThisform = Thisform
		endif type('loThisform.Name') <> 'C'
		
		* Get the row and column to use.
		
		if vartype(tnRow) <> 'N'
			lnRow = mrow(0, 3) + Thisform.Top + sysmetric(9) + sysmetric(4) + ;
				iif(_screen.Visible, sysmetric(9) + sysmetric(20), 0)
			lnCol = mcol(0, 3) + Thisform.Left + sysmetric(3)
		else
			lnRow = tnRow
			lnCol = tnCol
		endif vartype(tnRow) <> 'N'
		
		* Display the menu if there are any bars.
		
		if This.Menu.Count > 0
			lcName = evl(tcName, This.Name)
			This.Menu.ShowMenu(lnRow, lnCol, lcName)
		endif This.Menu.Count > 0
		
	ENDPROC

	PROCEDURE theme_assign
		lparameters tcTheme
		local lcColors
		lcColors = strextract(This.cThemes, '<theme name="' + tcTheme + '"', ;
			'/>', 1, 1)
		if not empty(lcColors)
			This.Theme        = tcTheme
			This.cThemeColors = lcColors
			This.SetAll('Theme', tcTheme)
			This.Menu.Theme = tcTheme
		endif not empty(lcColors)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfribbonmenu AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: addbar		&& Adds a bar to the menu
		*m: clear		&& Clears the menu
		*m: hidemenu		&& Hides the menu
		*m: showmenu		&& Displays the menu
		*m: visible_access
		*p: count		&& The number of bars in the menu
		*p: oform		&& A reference to an SFRibbonMenuForm object
		*p: padding		&& The spacing to use around bars
		*p: theme		&& The theme to use
		*p: visible		&& .T. if the menu is visible
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED oform
	*<PropValue>
		count = 0
		Name = "sfribbonmenu"
		oform = .NULL.
		padding = 2
		theme = Default
		visible = .F.
		Width = 17
		_memberdata = <VFPData>
			<memberdata name="addbar" display="AddBar"/>
			<memberdata name="abars[1]" display="aBars[1]"/>
			<memberdata name="showmenu" display="ShowMenu"/>
			<memberdata name="oform" display="oForm"/>
			<memberdata name="count" display="Count"/>
			<memberdata name="padding" display="Padding"/>
			<memberdata name="visible" display="Visible"/>
			<memberdata name="visible_access" display="Visible_Access"/>
			<memberdata name="theme" display="Theme"/>
			<memberdata name="hidemenu" display="HideMenu"/>
			<memberdata name="clear" display="Clear"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE addbar		&& Adds a bar to the menu
		*==============================================================================
		* Method:			AddBar
		* Status:			Public
		* Purpose:			Adds a bar to the menu
		* Author:			Doug Hennig
		* Last Revision:	04/03/2022
		* Parameters:		tcPrompt  - the prompt for the bar
		*					tcCommand - the command to execute
		*					tcImage   - the image for the bar; if it's surrounded with
		*						curly braces, it's an expression evaluated when the
		*						menu is dispplayed
		*					tcEnabled - the expression that enables the bar (optional)
		* Returns:			a reference to the new bar
		* Environment in:	none
		* Environment out:	This.oForm contains a reference to an SFRibbonMenuForm
		*						object
		*					a bar was added to the form and Count was incremented
		*==============================================================================
		
		lparameters tcPrompt, ;
			tcCommand, ;
			tcImage, ;
			tcEnabled
		local lcName, ;
			loBar, ;
			lcImage
		
		* Create the menu form if it doesn't already exist.
		
		if vartype(This.oForm) <> 'O'
			This.oForm  = newobject('SFRibbonMenuForm', 'SFRibbon.vcx')
		endif vartype(This.oForm) <> 'O'
		
		* Increment the count, assign a name to the bar, and add it to the form.
		
		This.Count = This.Count + 1
		lcName = 'Bar' + transform(This.Count)
		if empty(tcPrompt)
			This.oForm.NewObject(lcName, 'SFRibbonMenuSeparator', 'SFRibbon.vcx')
			loBar = This.oForm.&lcName
		else
			This.oForm.NewObject(lcName, 'SFRibbonMenuBar', 'SFRibbon.vcx')
			loBar = This.oForm.&lcName
			with loBar
				.Caption = tcPrompt
				.Command = strtran(evl(tcCommand, ''), 'Thisform', 'loThisform', -1, ;
					-1, 1)
					&& since the menu bar isn't in the form the ribbon is on,
					&& replace any reference to "Thisform" to a variable that contains
					&& a reference to the form
		* For some reason, Image_Assign is protected so do what that method does.
		*		.Image   = evl(tcImage, '')
				lcImage  = evl(tcImage, '')
				if left(lcImage, 1) = '{'
					.cImageExpression = substr(lcImage, 2, len(lcImage) - 2)
				else
					.imgButton.Picture = lcImage
				endif left(lcImage, 1) = '{'
				.EnabledExpression = strtran(evl(tcEnabled, ''), 'Thisform', ;
					'loThisform', -1, -1, 1)
					&& same reason to replace Thisform as above
			endwith
		endif empty(tcPrompt)
		loBar.Visible = .T.
		return loBar
		
	ENDPROC

	PROCEDURE clear		&& Clears the menu
		*==============================================================================
		* Method:			Clear
		* Status:			Public
		* Purpose:			Clears the menu
		* Author:			Doug Hennig
		* Last Revision:	01/18/2021
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	This.oForm is nulled and This.Count is set to 0
		*==============================================================================
		
		This.oForm = NULL
		This.Count = 0
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oForm = NULL
		
	ENDPROC

	PROCEDURE hidemenu		&& Hides the menu
		*==============================================================================
		* Method:			HideMenu
		* Status:			Public
		* Purpose:			Hides the menu
		* Author:			Doug Hennig
		* Last Revision:	12/27/2020
		* Parameters:		none
		* Returns:			none
		* Environment in:	This.oForm may contain a reference to the form displaying
		*						the menu
		* Environment out:	the form is hidden
		*==============================================================================
		
		if vartype(This.oForm) = 'O'
			This.oForm.Hide()
			This.oForm.oRibbon = NULL
		endif vartype(This.oForm) = 'O'
		
	ENDPROC

	PROCEDURE showmenu		&& Displays the menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays the menu
		* Author:			Doug Hennig
		* Last Revision:	04/05/2022
		* Parameters:		tnRow  - the row for the menu
		*					tnCol  - the column for the menu
		*					tcName - the name of the object with the menu
		* Returns:			none
		* Environment in:	This.Count contains the number of bars
		*					This.oForm contains a reference to the menu form
		*					This.Padding contains the spacing to use for bars
		*					This.Theme contains the current theme
		* Environment out:	the menu form is displayed
		*==============================================================================
		
		lparameters tnRow, ;
			tnCol, ;
			tcName
		local loForm, ;
			lnTop, ;
			lnWidth, ;
			lnI, ;
			lcName, ;
			loObject
		
		* Set the position and theme for each bar and get the maximum width.
		
		loForm  = This.oForm
		lnTop   = This.Padding
		lnWidth = 0
		for lnI = 1 to This.Count
			lcName = 'Bar' + transform(lnI)
			with loForm.&lcName
				.Top    = lnTop
				.Left   = This.Padding
				.Theme  = This.Theme
				lnTop   = lnTop + .Height
				lnWidth = max(lnWidth, .Width)
				if lnI = 1
					loForm.BackColor = .BackColor
				endif lnI = 1
				if .Type <> 'Separator'
		
		* If we have an enabled expression, use it.
		
					if not empty(.EnabledExpression)
						try
							.Enabled = evaluate(.EnabledExpression)
						catch
						endtry
					endif not empty(.EnabledExpression)
		
		* If we have an image expression, use it.
		
					if not empty(.cImageExpression)
						try
							lcImage = evaluate(.cImageExpression)
						catch
							lcImage = ''
						endtry
						.imgButton.Picture = lcImage
					endif not empty(.cImageExpression)
					.imgButton.Visible = not empty(.imgButton.Picture) and ;
						file(.imgButton.Picture)
				endif .Type <> 'Separator' ...
			endwith
		next lnI
		
		* Set the widths of the bars and the form size and position.
		
		for lnI = 1 to This.Count
			lcName = 'Bar' + transform(lnI)
			loForm.&lcName..Width = lnWidth
		next lnI
		with loForm
			.Height     = lnTop   + This.Padding
			.Width      = lnWidth + This.Padding * 2
			.Top        = tnRow
			.ObjectName = tcName
		
		* Adjust the menu position if it's outside the form (unless it's the menu form,
		* meaning this is a submenu).
		
			if tnCol + .Width > Thisform.Left + Thisform.Width and ;
				lower(Thisform.Class) <> 'sfribbonmenuform'
				.Left = Thisform.Width - .Width
			else
				.Left = tnCol
			endif tnCol + .Width ...
		endwith
		
		* Find the ribbon and set a reference to it in the form.
		
		loObject = This.Parent
		if lower(loObject.Parent.Class) = 'sfribbonmenuform'
			loObject = loObject.Parent.oRibbon
		else
			do while pemstatus(loObject, 'Type', 5) and loObject.Type <> 'Ribbon'
				loObject = loObject.Parent
			enddo while pemstatus(loObject, 'Type', 5) ...
		endif lower(loObject.Parent.Class) = 'sfribbonmenuform'
		loForm.oRibbon = loObject
		
		* Show the menu.
		
		loForm.Show()
		
	ENDPROC

	PROCEDURE visible_access
		return vartype(This.oForm) = 'O' and This.oForm.Visible
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfribbonmenubar AS sfribbontoolbarbuttonhorizontal OF "sfribbon.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: cimageexpression		&& The expression to use for the image at runtime
	*</DefinedPropArrayMethod>

	*<PropValue>
		BackColor = 255,255,255
		cimageexpression = 
		Name = "sfribbonmenubar"
		_memberdata = <VFPData>
			<memberdata name="enabledexpression" display="EnabledExpression"/>
			<memberdata name="cimageexpression" display="cImageExpression"/>
		</VFPData>
		imgButton.Name = "imgButton"
		imgButton.Top = 5
		lblButton.Name = "lblButton"
		lblButton.Top = 5
		imgDown.Height = 9
		imgDown.Name = "imgDown"
		imgDown.Picture = sfribbonright.png
		imgDown.Top = 9
		imgDown.Width = 7
	*</PropValue>
	
	PROCEDURE Click
		* Close the menu and do the usual behavior if we don't have a submenu. If we do
		* have a submenu, do nothing since there should be no behavior.
		
		if This.Menu.Count = 0
			This.Parent.Hide()
			dodefault()
			release loThisform
		endif This.Menu.Count = 0
		
	ENDPROC

	PROCEDURE MouseEnter
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		dodefault(tnButton, tnShift, tnXCoord, tnYCoord)
		
		* Display a submenu.
		
		if This.Menu.Count > 0
			This.ShowMenu()
		endif This.Menu.Count > 0
		
	ENDPROC

	PROCEDURE MouseLeave
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		dodefault(tnButton, tnShift, tnXCoord, tnYCoord)
		
		* Hide a submenu.
		
		if This.Menu.Count > 0
			This.Menu.HideMenu()
		endif This.Menu.Count > 0
		
	ENDPROC

	PROCEDURE showmenu
		* Display the submenu beside ourselves.
		
		if not This.Menu.Visible
			SFRibbonBase::ShowMenu(Thisform.Top + This.Top, ;
				objtoclient(This, 2) + Thisform.Left + This.Width)
		endif not This.Menu.Visible
		
	ENDPROC

	PROCEDURE theme_assign
		lparameters tcTheme
		dodefault(tcTheme)
		store This.GetThemeColor('menuitembackcolor') to This.BackColor, This.nBackColor
		This.HighlightedColor = This.GetThemeColor('menuitemhighlightcolor')
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfribbonmenuform AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="shpBorder" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tmrClick" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: calculatewidth		&& Calculate the width
		*p: objectname		&& The name of the object that has the menu
		*p: oribbon		&& A reference to the ribbon
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		AlwaysOnTop = .T.
		BackColor = 255,255,255
		BorderStyle = 0
		Caption = "sfribbonmenu"
		Desktop = .T.
		DoCreate = .T.
		Height = 68
		KeyPreview = .T.
		Left = 0
		Name = "sfribbonmenuform"
		objectname = 
		oribbon = .NULL.
		ShowInTaskBar = .F.
		ShowWindow = 2
		TitleBar = 0
		Top = 0
		Width = 136
		_memberdata = <VFPData>
			<memberdata name="calculatewidth" display="CalculateWidth"/>
			<memberdata name="objectname" display="ObjectName"/>
			<memberdata name="oribbon" display="oRibbon"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'shpBorder' AS shape WITH ;
		BackStyle = 0, ;
		BorderColor = 200,198,196, ;
		Height = 50, ;
		Left = 0, ;
		Name = "shpBorder", ;
		Top = 0, ;
		Width = 120
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'tmrClick' AS timer WITH ;
		Enabled = .F., ;
		Height = 23, ;
		Interval = 30, ;
		Left = 60, ;
		Name = "tmrClick", ;
		Top = 10, ;
		Width = 23
		*< END OBJECT: BaseClass="timer" />
	
	PROCEDURE calculatewidth		&& Calculate the width
		* This is needed by SFRibbonMenuBar.
		
	ENDPROC

	PROCEDURE Destroy
		This.oRibbon = NULL
		
	ENDPROC

	PROCEDURE Hide
		* Disable the timer and nuke the reference to the ribbon.
		
		This.tmrClick.Enabled = .F.
		This.oRibbon          = NULL
		
	ENDPROC

	PROCEDURE KeyPress
		* If the user presses the hotkey for a bar, execute that bar.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnShiftAltCtrl = 0
			lcHotKey = '\<' + upper(chr(tnKeyCode))
			for each loControl in This.Controls foxobject
				if pemstatus(loControl, 'Caption', 5) and ;
					lcHotKey $ upper(loControl.Caption)
					loControl.Click()
					exit
				endif pemstatus(loControl, 'Caption', 5) ...
			next loControl
		endif tnShiftAltCtrl = 0
		
	ENDPROC

	PROCEDURE Show
		lparameters tnStyle
		
		* If we have a reference to the ribbon, flag that the user hasn't clicked
		* outside the menu yet.
		
		if vartype(This.oRibbon) = 'O'
			This.oRibbon.lClickOutsideMenu = .F.
		endif vartype(This.oRibbon) = 'O'
		
		* Enable the timer that looks for mouse clicks.
		
		This.tmrClick.Enabled = .T.
		
		* Adjust the shape.
		
		This.shpBorder.Width  = This.Width
		This.shpBorder.Height = This.Height
		
	ENDPROC

	PROCEDURE tmrClick.Timer
		* If the user clicks outside the menu, close the menu.
		
		local llDown, ;
			laMouse[1], ;
			lnMouse, ;
			lcObjectName, ;
			llClickOutsideMenu, ;
			llHaveRibbon
		#define VK_LBUTTON 0x01
		declare integer GetAsyncKeyState in user32 integer vKey
		llDown             = GetAsyncKeyState(VK_LBUTTON) > 0 or mdown()
			&& use GetAsyncKeyState because MDOWN() is .F. if click outside form
		lnMouse            = amouseobj(laMouse, 1)
		lcObjectName       = icase(lnMouse = 0, '', ;
			type('laMouse[1].Parent.Type') = 'C' and 'Button' $ laMouse[1].Parent.Type, ;
			laMouse[1].Parent.Name, laMouse[1].Name)
			&& if the user clicks a member of the button, use the button name
		llClickOutsideMenu = llDown and (lnMouse = 0 or (laMouse[2] <> Thisform and ;
			not lcObjectName == Thisform.ObjectName))
		
		* If the user clicked outside this menu or another menu (this may be a parent
		* or a submenu), flag that so other menus know about it, hide the ribbon if
		* we're supposed to, and hide the menu.
		
		llHaveRibbon       = vartype(Thisform.oRibbon) = 'O'
		llClickOutsideMenu = llClickOutsideMenu or ;
			(llHaveRibbon and Thisform.oRibbon.lClickOutsideMenu)
		* Note: this code is left here in case we need to debug
		*debugout 'Down: ' + transform(llDown) + chr(13) + ;
			' Mouse: ' + transform(lnMouse) + chr(13) + ;
			iif(lnMouse = 0, '', ' Form: ' + laMouse[2].Name + chr(13)) + ;
			' Object: ' + lcObjectName + chr(13) + ;
			'This object: ' + Thisform.ObjectName + chr(13) + ;
			' Clickoutside: ' + transform(llClickOutsideMenu)
		if llClickOutsideMenu
			if llHaveRibbon
				Thisform.oRibbon.lClickOutsideMenu = .T.
				if Thisform.oRibbon.DisplayTabsOnly
					Thisform.oRibbon.ShowTabsOnly(.T., .T.)
				endif Thisform.oRibbon.DisplayTabsOnly
			endif llHaveRibbon
			This.Parent.Hide()
			release loThisform
		endif llClickOutsideMenu
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfribbonmenuseparator AS sfribbonbase OF "sfribbon.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="shpSeparator" UniqueID="" Timestamp="" />

	*<PropValue>
		BackStyle = 0
		Height = 4
		Name = "sfribbonmenuseparator"
		type = Separator
		Width = 200
	*</PropValue>

	ADD OBJECT 'shpSeparator' AS shape WITH ;
		Anchor = 10, ;
		BackStyle = 0, ;
		BorderColor = 225,223,221, ;
		BorderWidth = 0, ;
		FillColor = 225,223,221, ;
		FillStyle = 0, ;
		Height = 1, ;
		Left = 26, ;
		Name = "shpSeparator", ;
		Top = 2, ;
		Width = 174
		*< END OBJECT: BaseClass="shape" />
	
	PROCEDURE theme_assign
		lparameters tcTheme
		dodefault(tcTheme)
		store This.GetThemeColor('menuseparatorcolor') to This.shpSeparator.BorderColor, ;
			This.shpSeparator.FillColor
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfribbontab AS sfribbonbase OF "sfribbon.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblTab" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="linActive" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: addsection		&& Adds a section to the toolbar
		*m: calculatewidth		&& Calculates the width of the pad
		*m: caption_assign
		*m: selected_assign
		*m: toolbar_access
		*p: caption		&& The caption for the pad
		*p: highlightedcolor		&& The background color when the pad is highlighted
		*p: nbackcolor		&& The normal BackColor
		*p: selected		&& .T. if the pad is selected
		*p: toolbar		&& A reference to the toolbar for the pad
		*p: toolbarclass		&& The class for the toolbar displayed when this pad is selected
		*p: toolbarlibrary		&& The library for the toolbar displayed when this pad is selected
	*</DefinedPropArrayMethod>

	PROTECTED nbackcolor
	*<PropValue>
		BackColor = 243,242,241
		BorderWidth = 0
		caption = 
		Height = 30
		highlightedcolor = 250,249,248
		Name = "sfribbontab"
		nbackcolor = 0
		ogdi = .NULL.
		padding = 10
		selected = .F.
		toolbar = .NULL.
		toolbarclass = SFRibbonToolbar
		toolbarlibrary = SFRibbon.vcx
		type = Tab
		Width = 65
		_memberdata = <VFPData>
			<memberdata name="calculatewidth" display="CalculateWidth"/>
			<memberdata name="caption_assign" display="Caption_Assign"/>
			<memberdata name="highlightedcolor" display="HighlightedColor"/>
			<memberdata name="highlightedcolor_assign" display="HighlightedColor_Assign"/>
			<memberdata name="nbackcolor" display="nBackColor"/>
			<memberdata name="padding" display="Padding"/>
			<memberdata name="padding_assign" display="Padding_Assign"/>
			<memberdata name="selected_assign" display="Selected_Assign"/>
			<memberdata name="caption" display="Caption"/>
			<memberdata name="getcolor" display="GetColor"/>
			<memberdata name="selected" display="Selected"/>
			<memberdata name="toolbar" display="Toolbar"/>
			<memberdata name="toolbar_access" display="Toolbar_Access"/>
			<memberdata name="toolbarclass" display="ToolbarClass"/>
			<memberdata name="toolbarlibrary" display="ToolbarLibrary"/>
			<memberdata name="type" display="Type"/>
			<memberdata name="ogdi" display="oGDI"/>
			<memberdata name="addsection" display="AddSection"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'lblTab' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Label1", ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Left = 10, ;
		Name = "lblTab", ;
		Top = 7
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'linActive' AS shape WITH ;
		BorderColor = 16,110,190, ;
		BorderWidth = 0, ;
		FillColor = 16,110,190, ;
		FillStyle = 0, ;
		Height = 3, ;
		Left = 0, ;
		Name = "linActive", ;
		Top = 27, ;
		Visible = .F., ;
		Width = 65
		*< END OBJECT: BaseClass="shape" />
	
	PROCEDURE addsection		&& Adds a section to the toolbar
		*==============================================================================
		* Method:			AddSection
		* Status:			Public
		* Purpose:			Adds a section to the toolbar
		* Author:			Doug Hennig
		* Last Revision:	12/24/2020
		* Parameters:		tcName    - the name of the section (optional: if it isn't
		*						specified, Section<n> is used
		*					tcClass   - the class for the section (optional: if it
		*						isn't specified, the class in This.SectionClass is
		*						used)
		*					tcLibrary - the library for the section class (optional: if
		*						it isn't specified, the library in This.SectionLibrary
		*						is used)
		* Returns:			a reference to the new section
		* Environment in:	none
		* Environment out:	a section was added
		* Note:				this is just a helper method to make it easier to add a
		*						section, since the toolbar does all the work
		*==============================================================================
		
		lparameters tcName, ;
			tcClass, ;
			tcLibrary
		return This.Toolbar.AddSection(tcName, tcClass, tcLibrary)
		
	ENDPROC

	PROCEDURE calculatewidth		&& Calculates the width of the pad
		*==============================================================================
		* Method:			CalculateWidth
		* Status:			Public
		* Purpose:			Calculates the width of the tab
		* Author:			Doug Hennig
		* Last Revision:	12/22/2020
		* Parameters:		none
		* Returns:			none
		* Environment in:	Padding contains the desired space
		* Environment out:	the width of the container has been updated
		*					the position of the other tabs in the ribbon have been
		*						adjusted
		*==============================================================================
		
		local lnWidth
		lnWidth = This.oGDI.GetWidth(This.lblTab.Caption) + 2 * This.Padding
			&& This.lblTab.Width is inaccurate if the form isn't visible yet
		if This.Width <> lnWidth
			This.Width = lnWidth
			This.Parent.AdjustTabs()
		endif This.Width <> lnWidth
		
	ENDPROC

	PROCEDURE caption_assign
		lparameters tcCaption
		store tcCaption to This.Caption, This.lblTab.Caption
		This.CalculateWidth()
		
	ENDPROC

	PROCEDURE Click
		This.Selected = .T.
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		dodefault()
		This.Toolbar = NULL
		
	ENDPROC

	PROCEDURE Init
		dodefault()
		
		* Set the font for the SFGDIMeasureString object.
		
		This.oGDI.SetFont(This.lblTab.FontName, This.lblTab.FontSize)
		
		* Set Caption to itself so the width is calculated.
		
		if not empty(This.Caption)
			This.Caption = This.Caption
		endif not empty(This.Caption)
		
	ENDPROC

	PROCEDURE MouseEnter
		* When the user hovers the mouse over the tab, make the label bold and the line
		* full width (if it's visible).
		
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		This.nBackColor      = This.BackColor
		This.BackColor       = This.GetColor(This.HighlightedColor)
		This.lblTab.FontBold = .T.
		if This.linActive.Visible
			This.linActive.Left  = 0
			This.linActive.Width = This.Width
		endif This.linActive.Visible
		
	ENDPROC

	PROCEDURE MouseLeave
		* When the user moves the mouse outside the tab, make the label normal and the
		* line the width of the label (if it's visible).
		
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		This.BackColor       = This.nBackColor
		This.lblTab.FontBold = This.Selected
		if This.linActive.Visible
			This.linActive.Left  = This.lblTab.Left
			This.linActive.Width = This.lblTab.Width
		endif This.linActive.Visible
		
	ENDPROC

	PROCEDURE padding_assign
		lparameters tnPadding
		dodefault(tnPadding)
		This.CalculateWidth()
		
	ENDPROC

	PROCEDURE selected_assign
		* When we're selected, tell the ribbon that we are, make the label bold, our
		* toolbar visible, and the line visible and full width. When we aren't
		* selected, make the label normal and hide the line and toolbar.
		
		lparameters tlSelected
		local loControl, ;
			loParent
		This.Selected = tlSelected
		if This.Selected
			This.Parent.SelectTab(This)
			This.lblTab.FontBold   = .T.
			This.linActive.Visible = .T.
			This.Toolbar.Visible   = .T.
			This.linActive.Left    = 0
			This.linActive.Width   = This.Width
		
		* If one of the controls in the toolbar has focus and it isn't visible because
		* SFRibbon.SelectTab hid it, make it visible again.
		
			if type('Thisform.ActiveControl.Name') = 'C' and ;
				pemstatus(Thisform.ActiveControl, 'Visible', 5) and ;
				not Thisform.ActiveControl.Visible
				loControl = Thisform.ActiveControl
				loParent  = loControl.Parent
				do while vartype(loParent) = 'O' and loParent <> This.Toolbar and ;
					loParent <> Thisform
					loParent = loParent.Parent
				enddo while vartype(loParent) = 'O' ...
				if vartype(loParent) = 'O' and loParent = This.Toolbar
					loControl.Visible = .T.
				endif vartype(loParent) = 'O' ...
			endif type('Thisform.ActiveControl.Name') = 'C' ...
		else
			This.lblTab.FontBold   = .F.
			This.linActive.Visible = .F.
			This.Toolbar.Visible   = .F.
		endif This.Selected
		
	ENDPROC

	PROCEDURE theme_assign
		lparameters tcTheme
		dodefault(tcTheme)
		This.BackColor        = This.GetThemeColor('ribbonbackcolor')
		This.HighlightedColor = This.GetThemeColor('tabhighlightcolor')
		store This.GetThemeColor('tabbordercolor') to This.linActive.BorderColor, ;
			This.linActive.FillColor
		
	ENDPROC

	PROCEDURE toolbar_access
		* The first time the Toolbar property is accessed, instantiate the desired
		* class.
		
		local lcToolbarName
		if vartype('This.Toolbar') <> 'O'
			lcToolbarName = This.Name + 'Toolbar'
			if type('This.Parent.' + lcToolbarName + '.Name') <> 'C'
				This.Parent.NewObject(lcToolbarName, This.ToolbarClass, ;
					This.ToolbarLibrary)
				This.Parent.&lcToolbarName..Top = This.Height
			endif type('This.Parent.' + lcToolbarName + '.Name') <> 'C'
			This.Toolbar = This.Parent.&lcToolbarName
		endif vartype('This.Toolbar') <> 'O'
		return This.Toolbar
		
	ENDPROC

	PROCEDURE lblTab.Click
		This.Parent.Click()
		
	ENDPROC

	PROCEDURE linActive.Click
		This.Parent.Click()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfribbontoolbar AS sfribbonbase OF "sfribbon.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: addsection		&& Adds a section to the toolbar
		*m: adjustsections		&& Adjusts the location of sections when the width of one changes
		*p: sectionclass		&& The default section class
		*p: sectionlibrary		&& The default section library
	*</DefinedPropArrayMethod>

	*<PropValue>
		BackStyle = 0
		controltype = Section
		Height = 95
		Name = "sfribbontoolbar"
		sectionclass = SFRibbonToolbarSection
		sectionlibrary = SFRibbon.vcx
		type = Toolbar
		_memberdata = <VFPData>
			<memberdata name="type" display="Type"/>
			<memberdata name="addsection" display="AddSection"/>
			<memberdata name="sectionclass" display="SectionClass"/>
			<memberdata name="sectionlibrary" display="SectionLibrary"/>
			<memberdata name="adjustsections" display="AdjustSections"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE addsection		&& Adds a section to the toolbar
		*==============================================================================
		* Method:			AddSection
		* Status:			Public
		* Purpose:			Adds a section to the toolbar
		* Author:			Doug Hennig
		* Last Revision:	12/22/2020
		* Parameters:		tcName    - the name of the section (optional: if it isn't
		*						specified, Section<n> is used
		*					tcClass   - the class for the section (optional: if it
		*						isn't specified, the class in This.SectionClass is
		*						used)
		*					tcLibrary - the library for the section class (optional: if
		*						it isn't specified, the library in This.SectionLibrary
		*						is used)
		* Returns:			a reference to the new section
		* Environment in:	none
		* Environment out:	a section was added
		*==============================================================================
		
		lparameters tcName, ;
			tcClass, ;
			tcLibrary
		local lcName, ;
			lcClass, ;
			lcLibrary
		
		* Use defaults if the class and library weren't specified.
		
		lcName    = evl(tcName,    'Section' + transform(This.ControlCount))
		lcClass   = evl(tcClass,   This.SectionClass)
		lcLibrary = evl(tcLibrary, This.SectionLibrary)
		
		* Have AddControl do the work.
		
		return This.AddControl(lcName, lcClass, lcLibrary)
		
	ENDPROC

	PROCEDURE adjustsections		&& Adjusts the location of sections when the width of one changes
		*==============================================================================
		* Method:			AdjustSections
		* Status:			Public
		* Purpose:			Adjusts the location of sections when the width of one
		*						changes
		* Author:			Doug Hennig
		* Last Revision:	04/03/2022
		* Parameters:		none
		* Returns:			none
		* Environment in:	the toolbar contains sections
		* Environment out:	the sections have been adjusted so they abut each other and
		*						the toolbar width has been updated
		*==============================================================================
		
		local lnLeft, ;
			loControl
		lnLeft = 0
		for each loControl in This.Controls foxobject
			if lower(loControl.Class) <> 'sfribbonmenu'
				loControl.Left = lnLeft
				lnLeft = loControl.Left + loControl.Width
			endif lower(loControl.Class) <> 'sfribbonmenu'
		next loControl
		This.Width = lnLeft + 1
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfribbontoolbarbutton AS sfribbonbase OF "sfribbon.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="imgButton" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblButton" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="imgDown" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: calculatewidth		&& Calculates the width of the button
		*m: caption_assign
		*m: image_assign
		*m: onclick		&& Fired when the button is clicked if This.Command is empty and it doesn't have a submenu
		*m: tooltiptext_assign
		*m: visible_assign
		*m: wordwrap_assign
		*p: caption		&& The caption for the button label
		*p: command		&& The command to execute when the button is clicked
		*p: disabledimage		&& The disabled image for the button
		*p: enabledexpression		&& An expression that determines if the button is enabled
		*p: highlightedcolor		&& The color when the button is highlighted
		*p: image		&& The image for the button
		*p: nbackcolor		&& The normal backcolor
		*p: nlines		&& The number of lines in the label
		*p: wordwrap		&& .T. to auto-wrap the caption for the button; .F. to size the button for the caption
	*</DefinedPropArrayMethod>

	PROTECTED nbackcolor,nlines
	*<PropValue>
		BackColor = 243,242,241
		caption = 
		command = 
		disabledimage = 
		enabledexpression = 
		Height = 72
		highlightedcolor = 200,198,196
		image = 
		Name = "sfribbontoolbarbutton"
		nbackcolor = 0
		nlines = 0
		padding = 8
		ToolTipText = ""
		type = Button
		Visible = .T.
		Width = 72
		wordwrap = .F.
		_memberdata = <VFPData>
			<memberdata name="highlightedcolor" display="HighlightedColor"/>
			<memberdata name="nbackcolor" display="nBackColor"/>
			<memberdata name="caption" display="Caption"/>
			<memberdata name="caption_assign" display="Caption_Assign"/>
			<memberdata name="image" display="Image"/>
			<memberdata name="image_assign" display="Image_Assign"/>
			<memberdata name="getcolor" display="GetColor"/>
			<memberdata name="command" display="Command"/>
			<memberdata name="type" display="Type"/>
			<memberdata name="calculatewidth" display="CalculateWidth"/>
			<memberdata name="ogdi" display="oGDI"/>
			<memberdata name="padding" display="Padding"/>
			<memberdata name="addbar" display="AddBar"/>
			<memberdata name="nlines" display="nLines"/>
			<memberdata name="enabledexpression" display="EnabledExpression"/>
			<memberdata name="wordwrap" display="WordWrap"/>
			<memberdata name="wordwrap_assign" display="WordWrap_Assign"/>
			<memberdata name="visible" display="Visible"/>
			<memberdata name="visible_assign" display="Visible_Assign"/>
			<memberdata name="disabledimage" display="DisabledImage"/>
			<memberdata name="tooltiptext" display="ToolTipText"/>
			<memberdata name="tooltiptext_assign" display="ToolTipText_Assign"/>
			<memberdata name="onclick" display="OnClick"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'imgButton' AS image WITH ;
		BackStyle = 0, ;
		Height = 32, ;
		Left = 20, ;
		Name = "imgButton", ;
		Stretch = 1, ;
		Top = 5, ;
		Visible = .F., ;
		Width = 32, ;
		ZOrderSet = 0
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'imgDown' AS image WITH ;
		Height = 3, ;
		Left = 59, ;
		Name = "imgDown", ;
		Picture = sfribbondown.png, ;
		Top = 34, ;
		Visible = .F., ;
		Width = 7, ;
		ZOrderSet = 2
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'lblButton' AS label WITH ;
		Alignment = 2, ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Label1", ;
		FontName = "Segoe UI", ;
		Height = 32, ;
		Left = 2, ;
		Name = "lblButton", ;
		Top = 39, ;
		Width = 68, ;
		WordWrap = .T., ;
		ZOrderSet = 1
		*< END OBJECT: BaseClass="label" />
	
	PROCEDURE addbar
		*==============================================================================
		* Method:			AddBar
		* Status:			Public
		* Purpose:			Adds a bar to the dropdown menu
		* Author:			Doug Hennig
		* Last Revision:	12/27/2020
		* Parameters:		tcPrompt  - the prompt for the bar
		*					tcCommand - the command to execute
		*					tcImage   - the image for the bar
		*					tcEnabled - the expression that enables the bar (optional)
		* Returns:			a reference to the new bar
		* Environment in:	This.Menu contains an SFRibbonMenu object
		* Environment out:	a bar was added to the menu
		*					the down button is visible
		*==============================================================================
		
		lparameters tcPrompt, ;
			tcCommand, ;
			tcImage, ;
			tcEnabled
		local loBar
		loBar = dodefault(tcPrompt, tcCommand, tcImage, tcEnabled)
		if not This.imgDown.Visible
			This.imgDown.Visible = .T.
			if This.nLines > 1 and right(This.Caption, 2) <> '  '
				This.Caption = This.Caption + '  '
			endif This.nLines > 1 ...
		endif not This.imgDown.Visible
		This.CalculateWidth()
		return loBar
		
	ENDPROC

	PROCEDURE calculatewidth		&& Calculates the width of the button
		*==============================================================================
		* Method:			CalculateWidth
		* Status:			Public
		* Purpose:			Calculates the width of the button
		* Author:			Doug Hennig
		* Last Revision:	08/11/2023
		* Parameters:		none
		* Returns:			none
		* Environment in:	Padding contains the desired space
		*					WordWrap is .T. to wrap the caption, .F. to size the button
		* Environment out:	the width of the button and its section may been updated
		*					the down button has been positioned properly
		*					This.nLines contains the number of lines for the label
		*==============================================================================
		
		local lnWidth
		do case
			case not empty(This.Caption)
				if This.WordWrap
					This.oGDI.SetSize(This.lblButton.Width, This.lblButton.Height)
				endif This.WordWrap
				This.oGDI.MeasureString(This.lblButton.Caption)
				lnWidth = max(ceiling(This.oGDI.nWidth) + 2 * This.lblButton.Left, ;
					This.imgButton.Width + 2 * This.Padding)
					&& use the width of the label or the image, whichever is wider
					&& This.lblButton.Width is inaccurate if the form isn't visible yet
				if This.Width <> lnWidth and not This.WordWrap
					This.Width = lnWidth
					This.lblButton.Width = This.Width - 2 * This.lblButton.Left
				endif This.Width <> lnWidth ...
				This.imgButton.Left  = int((This.Width - This.imgButton.Width)/2)
					&& center the image
		
		* If there's one line of text, center the down button below the label.
		
				if This.oGDI.nLines = 1
					This.imgDown.Left = int((This.Width - This.imgDown.Width)/2)
					This.imgDown.Top  = This.lblButton.Top  + 24
				else
					This.imgDown.Left = This.lblButton.Left + This.lblButton.Width  - 5
					This.imgDown.Top  = This.lblButton.Top  + This.lblButton.Height - 10
				endif This.oGDI.nLines = 1
				This.nLines = This.oGDI.nLines
		
		* If the caption is empty and we're not word wrapping, adjust the width.
		
			case not This.WordWrap
				lnWidth              = This.Width
				This.Width           = This.imgButton.Width + (2 * This.Padding)
				This.Left            = This.Left + int((lnWidth - This.Width)/2)
				This.lblButton.Width = This.Width - 2 * This.lblButton.Left
				This.imgButton.Left  = int((This.Width - This.imgButton.Width) / 2)
					&& center the image
				This.imgDown.Left    = int((This.Width- This.imgDown.Width) / 2)
				This.imgDown.Top     = This.lblButton.Top  + 24
				This.nLines          = 1
		endcase
		This.Parent.CalculateWidth()
		
	ENDPROC

	PROCEDURE caption_assign
		lparameters tcCaption
		store tcCaption to This.Caption, This.lblButton.Caption
		This.CalculateWidth()
		
	ENDPROC

	PROCEDURE Click
		local lcCommand
		
		* If we're displaying tabs only, collapse the ribbon again if we're not
		* displaying a menu.
		
		try
			if This.Parent.Parent.Parent.DisplayTabsOnly and ;
				(not empty(This.Command) or This.Menu.Count = 0)
				This.Parent.Parent.Parent.ShowTabsOnly(.T., .T.)
			endif This.Parent.Parent.Parent.DisplayTabsOnly ...
		catch
		endtry
		do case
		
		* Execute the command if we have one. Note that references to Thisform have to
		* be changed to an object reference because EXECSCRIPT executes outside the
		* object mechanism.
		
			case not empty(This.Command)
				lcCommand = This.Command
				if type('loThisform') <> 'O'
					private loThisform
					loThisform = Thisform
				endif type('loThisform') <> 'O'
				if atc('loThisform', lcCommand) = 0
					lcCommand = strtran(lcCommand, 'Thisform', 'loThisform', -1, -1, 1)
				endif atc('loThisform', lcCommand) = 0
				execscript(lcCommand)
		
		* Display the menu if we have one.
		
			case This.Menu.Count > 0
				This.ShowMenu()
		
		* Raise the OnClick event.
		
			otherwise
				raiseevent(This, 'OnClick')
		endcase
		
	ENDPROC

	PROCEDURE enabled_assign
		lparameters tlEnabled
		do case
			case tlEnabled and not empty(This.Image) and file(This.Image)
				This.imgButton.Picture = This.Image
			case not tlEnabled and not empty(This.DisabledImage) and ;
				file(This.DisabledImage)
				This.imgButton.Picture = This.DisabledImage
		endcase
		dodefault(tlEnabled)
		
	ENDPROC

	PROCEDURE image_assign
		lparameters tcImage
		store tcImage to This.Image, This.imgButton.Picture
		if not empty(tcImage) and file(tcImage)
			This.imgButton.Visible = .T.
		endif not empty(tcImage) ...
		
	ENDPROC

	PROCEDURE Init
		* Set the font for the SFGDIMeasureString object.
		
		dodefault()
		This.oGDI.SetFont(This.lblButton.FontName, This.lblButton.FontSize)
		
		* Save the background color.
		
		This.nBackColor = This.BackColor
		
	ENDPROC

	PROCEDURE MouseEnter
		* When the user hovers the mouse over the button, highlight it if it's enabled.
		
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		local loControl
		if This.Enabled
			This.BackColor = This.GetColor(This.HighlightedColor)
		endif This.Enabled
		
		* Ensure other buttons aren't highlighted. This normally happens in MouseLeave
		* for the buttons but dropdown menus can interfere with that.
		
		for each loControl in This.Parent.Controls foxobject
			if loControl.Name <> This.Name and pemstatus(loControl, 'MouseLeave', 5)
				loControl.MouseLeave()
			endif loControl.Name <> This.Name
		next loControl
		
	ENDPROC

	PROCEDURE MouseLeave
		* When the user moves the mouse outside the button, make it normal.
		
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		if This.BackColor <> This.nBackColor
			This.BackColor = This.nBackColor
		endif This.BackColor <> This.nBackColor
		
	ENDPROC

	PROCEDURE onclick		&& Fired when the button is clicked if This.Command is empty and it doesn't have a submenu
		* Abstract method used for BINDEVENTS.
		
	ENDPROC

	PROCEDURE padding_assign
		lparameters tnPadding
		dodefault(tnPadding)
		This.CalculateWidth()
		
	ENDPROC

	PROCEDURE Refresh
		* If we have an EnabledExpression expression, use it to determine if the button
		* is enabled.
		
		local llEnabled
		if not empty(This.EnabledExpression)
			llEnabled = evaluate(This.EnabledExpression)
			if This.Enabled <> llEnabled
				This.Enabled = llEnabled
			endif This.Enabled <> llEnabled
		endif not empty(This.EnabledExpression)
		
	ENDPROC

	PROCEDURE showmenu
		local loLastMenu, ;
			loException, ;
			llInScreen
		
		* If the last menu is visible, close it.
		
		try
			if not pemstatus(_screen, 'oLastMenu', 5)
				_screen.AddProperty('oLastMenu')
			endif not pemstatus(_screen, 'oLastMenu', 5)
			loLastMenu = _screen.oLastMenu
			if vartype(nvl(loLastMenu, '')) = 'O' and loLastMenu.Menu.Visible
				loLastMenu.Menu.HideMenu()
				release loThisform
			endif vartype(nvl(loLastMenu, '')) = 'O' ...
			_screen.oLastMenu = This
		catch to loException
		endtry
		
		* Display the menu below ourselves.
		
		llInScreen = Thisform.HWnd = _screen.HWnd
		dodefault(objtoclient(This, 1) + ;
				This.Height + Thisform.Top + ;
				iif(llInScreen, 0, sysmetric(9) + sysmetric(4)) + ;
				iif(Thisform.Desktop or llInScreen, 0, sysmetric(9) + sysmetric(20)), ;
			objtoclient(This, 2) + Thisform.Left + iif(llInScreen, 0, sysmetric(3)))
		
		* Clear the reference.
		
		_screen.oLastMenu = NULL
		
	ENDPROC

	PROCEDURE theme_assign
		lparameters tcTheme
		dodefault(tcTheme)
		store This.GetThemeColor('ribbonbackcolor') to This.BackColor, This.nBackColor
		This.HighlightedColor = This.GetThemeColor('buttonhighlightcolor')
		
	ENDPROC

	PROCEDURE tooltiptext_assign
		lparameters tcValue
		This.ToolTipText = tcValue
		This.SetAll('ToolTipText', tcValue)
		
	ENDPROC

	PROCEDURE visible_assign
		lparameters tlVisible
		This.Visible = tlVisible
		This.Parent.CalculateWidth()
		
	ENDPROC

	PROCEDURE wordwrap_assign
		lparameters tlWordWrap
		This.WordWrap = tlWordWrap
		This.CalculateWidth()
		
	ENDPROC

	PROCEDURE imgButton.Click
		This.Parent.Click()
		
	ENDPROC

	PROCEDURE imgDown.Click
		This.Parent.Click()
		
	ENDPROC

	PROCEDURE lblButton.Click
		This.Parent.Click()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfribbontoolbarbuttonhorizontal AS sfribbontoolbarbutton OF "sfribbon.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<PropValue>
		Height = 25
		Name = "sfribbontoolbarbuttonhorizontal"
		type = HButton
		Width = 100
		imgButton.Height = 16
		imgButton.Left = 5
		imgButton.Name = "imgButton"
		imgButton.Top = 5
		imgButton.Width = 16
		lblButton.Alignment = 0
		lblButton.AutoSize = .T.
		lblButton.Left = 30
		lblButton.Name = "lblButton"
		lblButton.Top = 5
		lblButton.WordWrap = .F.
		imgDown.Height = 3
		imgDown.Left = 85
		imgDown.Name = "imgDown"
		imgDown.Top = 10
		imgDown.Width = 7
	*</PropValue>
	
	PROCEDURE calculatewidth		&& Calculates the width of the button
		*==============================================================================
		* Method:			CalculateWidth
		* Status:			Public
		* Purpose:			Calculates the width of the button
		* Author:			Doug Hennig
		* Last Revision:	12/23/2020
		* Parameters:		none
		* Returns:			none
		* Environment in:	Padding contains the desired space
		* Environment out:	the width of the button and its section has been updated
		*==============================================================================
		
		local lnCaptionWidth, ;
			lnWidth
		This.oGDI.MeasureString(This.lblButton.Caption)
		lnCaptionWidth = ceiling(This.oGDI.nWidth)
			&& This.lblButton.Width is inaccurate if the form isn't visible yet
		lnWidth        = This.lblButton.Left + lnCaptionWidth + ;
			iif(This.Menu.Count > 0, This.imgDown.Width + 5, 0)
		if This.Width <> lnWidth
			This.Width        = lnWidth
			This.imgDown.Left = This.lblButton.Left + lnCaptionWidth
		*	This.lblButton.Left = This.imgButton.Left + This.imgButton.Width + 5
		*	This.lblButton.Top  = This.imgButton.Top
		*	This.imgDown.Top    = This.imgButton.Top + int((This.imgButton.Height - This.imgDown.Height)/2)
				&& for some reason, these won't stay in the correct place at design
				&& time so uncomment these three lines
		endif This.Width <> lnWidth
		This.nLines = This.oGDI.nLines
		This.Parent.CalculateWidth()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfribbontoolbarsection AS sfribbonbase OF "sfribbon.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblSection" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="linSeparator" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: addbutton		&& Adds a button to the section
		*m: addhorizontalbutton		&& Adds a horizontal button to the section
		*m: calculatewidth		&& Calculates the width of the section
		*m: caption_assign
		*p: buttonclass		&& The default button class
		*p: buttonlibrary		&& The default button library
		*p: caption		&& The caption for the section
		*p: horizontalbuttonclass		&& The default horizontal button class
		*p: horizontalbuttonlibrary		&& The default horizontal button library
	*</DefinedPropArrayMethod>

	*<PropValue>
		BackStyle = 0
		buttonclass = SFRibbonToolbarButton
		buttonlibrary = SFRibbon.vcx
		caption = 
		controltype = Button
		Height = 95
		horizontalbuttonclass = SFRibbonToolbarButtonHorizontal
		horizontalbuttonlibrary = SFRibbon.vcx
		Name = "sfribbontoolbarsection"
		padding = 8
		type = Section
		Width = 200
		_memberdata = <VFPData>
			<memberdata name="addbutton" display="AddButton"/>
			<memberdata name="caption" display="Caption"/>
			<memberdata name="caption_assign" display="Caption_Assign"/>
			<memberdata name="calculatewidth" display="CalculateWidth"/>
			<memberdata name="padding" display="Padding"/>
			<memberdata name="buttonclass" display="ButtonClass"/>
			<memberdata name="buttonlibrary" display="ButtonLibrary"/>
			<memberdata name="addhorizontalbutton" display="AddHorizontalButton"/>
			<memberdata name="horizontalbuttonclass" display="HorizontalButtonClass"/>
			<memberdata name="horizontalbuttonlibrary" display="HorizontalButtonLibrary"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'lblSection' AS label WITH ;
		Alignment = 2, ;
		BackStyle = 0, ;
		Caption = "Label1", ;
		FontName = "Segoe UI", ;
		FontSize = 8, ;
		Left = 0, ;
		Name = "lblSection", ;
		Top = 77, ;
		Width = 200, ;
		WordWrap = .T.
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'linSeparator' AS line WITH ;
		BorderColor = 179,176,173, ;
		Height = 86, ;
		Left = 198, ;
		Name = "linSeparator", ;
		Top = 5, ;
		Width = 0
		*< END OBJECT: BaseClass="line" />
	
	PROCEDURE addbutton		&& Adds a button to the section
		*==============================================================================
		* Method:			AddButton
		* Status:			Public
		* Purpose:			Adds a button to the section
		* Author:			Doug Hennig
		* Last Revision:	12/22/2020
		* Parameters:		tcName    - the name of the button (optional: if it isn't
		*						specified, Button<n> is used
		*					tcClass   - the class for the button (optional: if it isn't
		*						specified, the class in This.ButtonClass is used)
		*					tcLibrary - the library for the button class (optional: if
		*						it isn't passed, the library in This.ButtonLibrary is
		*						used)
		* Returns:			a reference to the new button
		* Environment in:	none
		* Environment out:	a button was added
		*==============================================================================
		
		lparameters tcName, ;
			tcClass, ;
			tcLibrary
		local lcName, ;
			lcClass, ;
			lcLibrary, ;
			loControl
		
		* Use defaults if the parameters weren't specified.
		
		lcName    = evl(tcName,  'Button' + transform(This.ControlCount))
		lcClass   = evl(tcClass, This.ButtonClass)
		lcLibrary = iif(pcount() = 3, tcLibrary, This.ButtonLibrary)
		
		* Have AddControl do the work.
		
		loControl = This.AddControl(lcName, lcClass, lcLibrary)
		
		* Adjust the width.
		
		This.CalculateWidth()
		return loControl
		
	ENDPROC

	PROCEDURE addhorizontalbutton		&& Adds a horizontal button to the section
		*==============================================================================
		* Method:			AddHorizontalButton
		* Status:			Public
		* Purpose:			Adds a horizontal button to the section
		* Author:			Doug Hennig
		* Last Revision:	12/28/2020
		* Parameters:		tcName    - the name of the button (optional: if it isn't
		*						specified, Button<n> is used
		*					tcClass   - the class for the button (optional: if it isn't
		*						specified, the class in This.HorizontalButtonClass is
		*						used)
		*					tcLibrary - the library for the button class (optional: if
		*						it isn't passed, the library in
		*						This.HorizontalButtonLibrary is used)
		* Returns:			a reference to the new button
		* Environment in:	none
		* Environment out:	a button was added
		*==============================================================================
		
		lparameters tcName, ;
			tcClass, ;
			tcLibrary
		return This.AddButton(tcName, This.HorizontalButtonClass, ;
			This.HorizontalButtonLibrary)
		
	ENDPROC

	PROCEDURE calculatewidth		&& Calculates the width of the section
		*==============================================================================
		* Method:			CalculateWidth
		* Status:			Public
		* Purpose:			Calculates the width of the section
		* Author:			Doug Hennig
		* Last Revision:	07/08/2023
		* Parameters:		none
		* Returns:			none
		* Environment in:	none
		* Environment out:	the position of the separator and the width of the
		*						container and the label have been updated
		*==============================================================================
		
		local lnWidth, ;
			lnControls, ;
			loControl, ;
			lcType, ;
			llVertical, ;
			lnLeft, ;
			lnTop, ;
			loUnique, ;
			lnCaptionWidth
		lnWidth    = 0
		lnControls = 0
		for each loControl in This.Controls foxobject
			lcType = iif(pemstatus(loControl, 'Type', 5), loControl.Type, '')
			do case
		
		* Do nothing if this is the separator or section label or the control isn't
		* visible.
		
				case inlist(loControl.Name, 'linSeparator', 'lblSection') or ;
					(pemstatus(loControl, 'Visible', 5) and not loControl.Visible)
					loop
		
		* Horizontal button: if we already have enough buttons in this column, move to
		* the next column. Set the Left property and if this isn't the first one, set
		* the Top property. Then increment the total width value.
		
				case lcType = 'HButton'
					if llVertical and lnTop + loControl.Height > This.Height
						llVertical = .F.
					endif llVertical ...
					if llVertical
						loControl.Top  = lnTop
						loControl.Left = lnLeft
					else
						loControl.Left = max(lnWidth, This.Padding)
						lnLeft         = loControl.Left
					endif llVertical
					lnWidth    = max(lnWidth, loControl.Left + loControl.Width)
					lnTop      = loControl.Top + loControl.Height
					llVertical = .T.
		
		* For all other controls, move the control to the next Left position and
		* increment the total width value.
		
				otherwise
					loControl.Left = max(lnWidth, This.Padding)
					lnWidth        = max(lnWidth, loControl.Left + loControl.Width)
					llVertical     = .F.
			endcase
			lnControls = lnControls + 1
			loUnique   = loControl
		next loControl
		lnCaptionWidth = This.oGDI.GetWidth(This.Caption)
		This.linSeparator.Left = max(lnWidth, lnCaptionWidth) + This.Padding
		store This.linSeparator.Left to This.Width, This.lblSection.Width
		This.Parent.AdjustSections()
		
		* If we have a single control, center it in case the lower label width is
		* bigger than the control width.
		
		if lnControls = 1
			loUnique.Left = ceiling((This.Width - loUnique.Width) / 2)
		endif lnControls = 1
		
	ENDPROC

	PROCEDURE caption_assign
		lparameters tcCaption
		store tcCaption to This.Caption, This.lblSection.Caption
		
	ENDPROC

	PROCEDURE Init
		* Set the font for the SFGDIMeasureString object.
		
		dodefault()
		This.oGDI.SetFont(This.lblSection.FontName, This.lblSection.FontSize)
		
	ENDPROC

	PROCEDURE padding_assign
		lparameters tnPadding
		dodefault(tnPadding)
		This.CalculateWidth()
		
	ENDPROC

	PROCEDURE theme_assign
		lparameters tcTheme
		dodefault(tcTheme)
		This.linSeparator.BorderColor = This.GetThemeColor('sectionseparatorcolor')
		
	ENDPROC

ENDDEFINE
